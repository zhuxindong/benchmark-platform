# -*- coding: utf-8 -*-
"""
基准测试相关路由 - 使用 ORM
"""
from fastapi import APIRouter, HTTPException, status, Depends, Request
from pydantic import BaseModel
from typing import Optional, Dict, List
import re
from datetime import datetime, timezone
from sqlalchemy.orm import Session
from sqlalchemy import func, or_

from app.dependencies.database import get_db
from app.dependencies.auth import get_current_user_from_token
from app.models import User, BenchmarkResult, DeviceType
from app.utils.device_classifier import DeviceTypeClassifier

router = APIRouter(prefix="/api/v1/benchmarks", tags=["基准测试"])


class BenchmarkSubmitRequest(BaseModel):
    cpu_model: str
    cpu_cores: int
    memory_gb: float
    phase1_wall_time: float
    phase2_wall_time: float
    overall_wall_time: float
    device_type: Optional[str] = None
    device_type_confidence: Optional[float] = None


@router.post("/parse")
async def parse_benchmark_text(request: Request):
    """解析基准测试文本"""
    try:
        body = await request.json()
        text = body.get("text", "")

        if not text:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="缺少基准测试结果文本"
            )

        parsed_data = {
            "cpu_model": "",
            "cpu_cores": None,
            "memory_gb": None,
            "phase1_wall_time": None,
            "phase2_wall_time": None,
            "overall_wall_time": None
        }

        # 解析系统信息
        cpu_match = re.search(r'CPU\s*[:\s]\s*(.+?)(?:\n|$)', text, re.IGNORECASE)
        if cpu_match:
            parsed_data["cpu_model"] = cpu_match.group(1).strip()

        cores_match = re.search(r'(?:Cores|cores?|Cores?_logical)\s*[:\s]\s*(\d+)', text, re.IGNORECASE)
        if cores_match:
            parsed_data["cpu_cores"] = int(cores_match.group(1))

        memory_match = re.search(r'Memory\s*[:\s]\s*([\d.]+)\s*(?:GB|gb|GiB|gib)', text, re.IGNORECASE)
        if memory_match:
            parsed_data["memory_gb"] = float(memory_match.group(1))

        # 解析时间信息
        phase1_match = re.search(r'\[Phase\s*1\][\s\S]*?wall_time\s*[:\s]\s*([\d.]+)\s*s', text, re.IGNORECASE)
        if phase1_match:
            parsed_data["phase1_wall_time"] = float(phase1_match.group(1))

        phase2_match = re.search(r'\[Phase\s*2\][\s\S]*?wall_time\s*[:\s]\s*([\d.]+)\s*s', text, re.IGNORECASE)
        if phase2_match:
            parsed_data["phase2_wall_time"] = float(phase2_match.group(1))

        total_match = re.search(r'\[Overall\][\s\S]*?wall_time\s*[:\s]\s*([\d.]+)\s*s', text, re.IGNORECASE)
        if total_match:
            parsed_data["overall_wall_time"] = float(total_match.group(1))

        return {
            "success": True,
            "data": parsed_data,
            "message": "解析成功"
        }

    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"解析失败: {str(e)}"
        )


@router.post("/classify-device-type")
async def classify_device_type(request: Dict[str, str]):
    """设备类型分类API"""
    try:
        cpu_model = request.get("cpu_model", "").strip()
        if not cpu_model:
            return {
                "success": False,
                "message": "CPU型号不能为空"
            }

        classifier = DeviceTypeClassifier()
        device_type, confidence = classifier.classify_cpu(cpu_model)

        return {
            "success": True,
            "data": {
                "cpu_model": cpu_model,
                "device_type": device_type,
                "device_type_confidence": confidence,
                "classification_text": f"设备类型: {device_type.upper()} (置信度: {confidence:.2f})"
            }
        }

    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"设备类型分类失败: {str(e)}"
        )


@router.post("/submit")
async def submit_benchmark_result(
    request: BenchmarkSubmitRequest,
    current_user: User = Depends(get_current_user_from_token),
    db: Session = Depends(get_db)
):
    """提交基准测试结果"""
    try:
        # 检查用户已有结果数量 - 使用 ORM
        user_result_count = db.query(BenchmarkResult).filter(
            BenchmarkResult.user_id == current_user.id
        ).count()

        # 如果用户已经有3条记录，拒绝提交
        if user_result_count >= 3:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="每个用户最多只能提交3条基准测试记录"
            )

        # 如果未提供设备类型，使用CPU型号进行分类
        device_type_str = request.device_type
        device_type_confidence = request.device_type_confidence

        if not device_type_str:
            classifier = DeviceTypeClassifier()
            device_type_str, device_type_confidence = classifier.classify_cpu(request.cpu_model)

        # 转换设备类型字符串为枚举
        device_type_enum = DeviceType[device_type_str] if device_type_str in ['server', 'consumer', 'unknown'] else DeviceType.unknown

        # 插入新结果 - 使用 ORM
        new_result = BenchmarkResult(
            user_id=current_user.id,
            username=current_user.username,
            cpu_model=request.cpu_model,
            cpu_cores=request.cpu_cores,
            memory_gb=request.memory_gb,
            phase1_wall_time=request.phase1_wall_time,
            phase2_wall_time=request.phase2_wall_time,
            overall_wall_time=request.overall_wall_time,
            device_type=device_type_enum,
            device_type_confidence=device_type_confidence,
            submitted_at=datetime.now(timezone.utc)
        )

        db.add(new_result)
        db.commit()
        db.refresh(new_result)

        return {
            "success": True,
            "message": f"基准测试结果提交成功（这是您的第{user_result_count + 1}条记录）",
            "data": {
                "id": new_result.id,
                "action": "created",
                "user_result_count": user_result_count + 1,
                "remaining_slots": 3 - (user_result_count + 1)
            }
        }

    except HTTPException:
        raise
    except Exception as e:
        db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"提交基准测试结果失败: {str(e)}"
        )


@router.get("/leaderboard")
async def get_leaderboard(device_type: Optional[str] = None, limit: int = 20, page: int = 1, reverse: bool = False):
    """获取排行榜数据"""
    try:
        db = get_db_connection()
        cursor = db.cursor(pymysql.cursors.DictCursor)

        # 计算偏移量
        offset = (page - 1) * limit

        # 构建WHERE条件
        where_conditions = ["br.overall_wall_time IS NOT NULL"]
        params = []

        if device_type:
            where_conditions.append("br.device_type = %s")
            params.append(device_type)

        where_clause = " AND ".join(where_conditions)

        # 根据 reverse 参数决定排序方向
        order_direction = "DESC" if reverse else "ASC"

        # 获取排行榜数据
        cursor.execute(f"""
            SELECT br.*, u.username, u.avatar_url
            FROM benchmark_results br
            JOIN users u ON br.user_id = u.id
            WHERE {where_clause}
            ORDER BY br.overall_wall_time {order_direction}
            LIMIT %s OFFSET %s
        """, params + [limit, offset])

        results = cursor.fetchall()

        # 格式化数据
        leaderboard = []
        rank = offset + 1
        for result in results:
            leaderboard.append({
                "rank": rank,
                "username": result["username"],
                "avatar_url": result["avatar_url"],
                "cpu_model": result["cpu_model"],
                "cpu_cores": result["cpu_cores"],
                "memory_gb": float(result["memory_gb"]) if result["memory_gb"] else None,
                "phase1_wall_time": float(result["phase1_wall_time"]) if result["phase1_wall_time"] else None,
                "phase2_wall_time": float(result["phase2_wall_time"]) if result["phase2_wall_time"] else None,
                "overall_wall_time": float(result["overall_wall_time"]) if result["overall_wall_time"] else None,
                "device_type": result.get("device_type", "unknown"),
                "device_type_confidence": float(result["device_type_confidence"]) if result.get("device_type_confidence") else 0.0,
                "submitted_at": result["submitted_at"].isoformat() if result["submitted_at"] else None
            })
            rank += 1

        # 获取总数
        count_params = params.copy() if params else []
        cursor.execute(f"SELECT COUNT(*) as total FROM benchmark_results br WHERE {where_clause}", count_params)
        total = cursor.fetchone()["total"]

        cursor.close()
        db.close()

        return {
            "success": True,
            "data": {
                "leaderboard": leaderboard,
                "pagination": {
                    "page": page,
                    "limit": limit,
                    "total": total,
                    "total_pages": (total + limit - 1) // limit
                }
            }
        }

    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"获取排行榜失败: {str(e)}"
        )


@router.get("/my-result")
async def get_my_benchmark_result(current_user = Depends(get_current_user_from_token)):
    """获取当前用户的基准测试结果"""
    try:
        db = get_db_connection()
        cursor = db.cursor(pymysql.cursors.DictCursor)

        cursor.execute("""
            SELECT br.*, u.username, u.avatar_url
            FROM benchmark_results br
            JOIN users u ON br.user_id = u.id
            WHERE br.user_id = %s
            ORDER BY br.submitted_at DESC
        """, (current_user["id"],))

        results = cursor.fetchall()

        # 获取用户总记录数
        cursor.execute("SELECT COUNT(*) as total_count FROM benchmark_results WHERE user_id = %s", (current_user["id"],))
        count_result = cursor.fetchone()
        total_count = count_result["total_count"]
        remaining_slots = max(0, 3 - total_count)

        cursor.close()
        db.close()

        if not results:
            return {
                "success": True,
                "data": {
                    "results": [],
                    "total_count": 0,
                    "remaining_slots": 3
                },
                "message": "用户还没有上传基准测试结果"
            }

        # 格式化结果
        formatted_results = []
        for result in results:
            formatted_results.append({
                "id": result["id"],
                "username": result["username"],
                "avatar_url": result["avatar_url"],
                "cpu_model": result["cpu_model"],
                "cpu_cores": result["cpu_cores"],
                "memory_gb": float(result["memory_gb"]) if result["memory_gb"] else None,
                "phase1_wall_time": float(result["phase1_wall_time"]) if result["phase1_wall_time"] else None,
                "phase2_wall_time": float(result["phase2_wall_time"]) if result["phase2_wall_time"] else None,
                "overall_wall_time": float(result["overall_wall_time"]) if result["overall_wall_time"] else None,
                "device_type": result.get("device_type", "unknown"),
                "device_type_confidence": float(result["device_type_confidence"]) if result.get("device_type_confidence") else 0.0,
                "submitted_at": result["submitted_at"].isoformat() if result["submitted_at"] else None,
                "updated_at": result["updated_at"].isoformat() if result["updated_at"] else None
            })

        return {
            "success": True,
            "data": {
                "results": formatted_results,
                "total_count": total_count,
                "remaining_slots": remaining_slots
            },
            "message": f"找到 {total_count} 条基准测试记录，还可提交 {remaining_slots} 条"
        }

    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"获取用户基准测试结果失败: {str(e)}"
        )


@router.get("/my-ranks")
async def get_my_ranks(
    device_type: Optional[str] = None,
    reverse: bool = False,
    current_user = Depends(get_current_user_from_token)
):
    """获取当前用户在排行榜中的所有排名信息"""
    try:
        db = get_db_connection()
        cursor = db.cursor(pymysql.cursors.DictCursor)

        # 构建WHERE条件
        where_conditions = ["br.overall_wall_time IS NOT NULL", "br.user_id = %s"]
        params = [current_user["id"]]

        if device_type:
            where_conditions.append("br.device_type = %s")
            params.append(device_type)

        where_clause = " AND ".join(where_conditions)

        # 获取用户的所有记录
        cursor.execute(f"""
            SELECT br.*
            FROM benchmark_results br
            WHERE {where_clause}
            ORDER BY br.overall_wall_time ASC
        """, params)

        user_records = cursor.fetchall()

        if not user_records:
            cursor.close()
            db.close()
            return {
                "success": True,
                "data": {"records": []},
                "message": "用户没有符合条件的记录"
            }

        # 为每条记录计算排名
        records_with_ranks = []
        for record in user_records:
            rank_where_conditions = ["overall_wall_time IS NOT NULL"]
            rank_params = []

            if device_type:
                rank_where_conditions.append("device_type = %s")
                rank_params.append(device_type)

            rank_where_clause = " AND ".join(rank_where_conditions)

            # 根据reverse参数决定排名计算方式
            if reverse:
                cursor.execute(f"""
                    SELECT COUNT(*) + 1 as `rank`
                    FROM benchmark_results
                    WHERE {rank_where_clause}
                    AND overall_wall_time > %s
                """, rank_params + [record["overall_wall_time"]])
            else:
                cursor.execute(f"""
                    SELECT COUNT(*) + 1 as `rank`
                    FROM benchmark_results
                    WHERE {rank_where_clause}
                    AND overall_wall_time < %s
                """, rank_params + [record["overall_wall_time"]])

            rank_result = cursor.fetchone()
            rank = rank_result["rank"]

            # 获取总数
            cursor.execute(f"""
                SELECT COUNT(*) as total
                FROM benchmark_results
                WHERE {rank_where_clause}
            """, rank_params)
            total_result = cursor.fetchone()
            total = total_result["total"]

            # 计算所在页码
            page = (rank - 1) // 20 + 1

            records_with_ranks.append({
                "rank": rank,
                "total": total,
                "page": page,
                "device_type": record.get("device_type", "unknown"),
                "cpu_model": record["cpu_model"],
                "overall_wall_time": float(record["overall_wall_time"]) if record["overall_wall_time"] else None,
                "record_id": record["id"]
            })

        cursor.close()
        db.close()

        return {
            "success": True,
            "data": {"records": records_with_ranks}
        }

    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"获取用户排名失败: {str(e)}"
        )


@router.get("/{benchmark_id}")
async def get_benchmark_detail(benchmark_id: int, current_user: dict = Depends(get_current_user_from_token)):
    """获取单个基准测试记录详情"""
    try:
        conn = get_db_connection()
        cursor = conn.cursor()

        user_id = current_user.get("id")
        if not user_id:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="用户身份验证失败"
            )

        cursor.execute("""
            SELECT id, cpu_model, cpu_cores, memory_gb, phase1_wall_time, phase2_wall_time,
                   overall_wall_time, device_type, device_type_confidence, submitted_at, updated_at
            FROM benchmark_results
            WHERE id = %s AND user_id = %s
        """, (benchmark_id, user_id))

        record = cursor.fetchone()

        if not record:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="记录不存在或无权限访问"
            )

        cursor.close()
        conn.close()

        return {
            "success": True,
            "data": {
                "id": record[0],
                "cpu_model": record[1],
                "cpu_cores": record[2],
                "memory_gb": record[3],
                "phase1_wall_time": record[4],
                "phase2_wall_time": record[5],
                "overall_wall_time": record[6],
                "device_type": record[7],
                "device_type_confidence": record[8],
                "submitted_at": record[9],
                "updated_at": record[10]
            },
            "message": "获取记录详情成功"
        }

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"获取记录详情失败: {str(e)}"
        )


@router.put("/{benchmark_id}")
async def update_benchmark(benchmark_id: int, request: Dict, current_user: dict = Depends(get_current_user_from_token)):
    """更新基准测试记录"""
    try:
        conn = get_db_connection()
        cursor = conn.cursor()

        user_id = current_user.get("id")
        if not user_id:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="用户身份验证失败"
            )

        # 检查记录是否存在且属于当前用户
        cursor.execute(
            "SELECT id FROM benchmark_results WHERE id = %s AND user_id = %s",
            (benchmark_id, user_id)
        )
        record = cursor.fetchone()

        if not record:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="记录不存在或无权限修改"
            )

        # 获取请求数据
        cpu_model = request.get("cpu_model", "")
        cpu_cores = request.get("cpu_cores", 0)
        memory_gb = request.get("memory_gb", 0)
        phase1_wall_time = request.get("phase1_wall_time", 0)
        phase2_wall_time = request.get("phase2_wall_time", 0)
        overall_wall_time = request.get("overall_wall_time", 0)
        device_type = request.get("device_type", "unknown")
        device_type_confidence = request.get("device_type_confidence", 0)

        # 更新记录
        cursor.execute("""
            UPDATE benchmark_results
            SET cpu_model = %s,
                cpu_cores = %s,
                memory_gb = %s,
                phase1_wall_time = %s,
                phase2_wall_time = %s,
                overall_wall_time = %s,
                device_type = %s,
                device_type_confidence = %s,
                updated_at = CURRENT_TIMESTAMP
            WHERE id = %s AND user_id = %s
        """, (
            cpu_model, cpu_cores, memory_gb, phase1_wall_time, phase2_wall_time,
            overall_wall_time, device_type, device_type_confidence, benchmark_id, user_id
        ))

        conn.commit()
        cursor.close()
        conn.close()

        return {
            "success": True,
            "message": "记录更新成功",
            "data": {
                "updated_record_id": benchmark_id
            }
        }

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"更新记录失败: {str(e)}"
        )


@router.delete("/{benchmark_id}")
async def delete_benchmark(benchmark_id: int, current_user: dict = Depends(get_current_user_from_token)):
    """删除基准测试记录"""
    try:
        conn = get_db_connection()
        cursor = conn.cursor()

        user_id = current_user.get("id")
        if not user_id:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="用户身份验证失败"
            )

        # 检查记录是否存在且属于当前用户
        check_sql = "SELECT id, cpu_model, overall_wall_time, user_id FROM benchmark_results WHERE id = %s AND user_id = %s"
        cursor.execute(check_sql, (benchmark_id, user_id))
        record = cursor.fetchone()

        if not record:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="记录不存在或无权限删除"
            )

        # 删除记录
        cursor.execute("DELETE FROM benchmark_results WHERE id = %s AND user_id = %s", (benchmark_id, user_id))
        conn.commit()

        # 获取用户更新后的记录数量
        cursor.execute("SELECT COUNT(*) FROM benchmark_results WHERE user_id = %s", (user_id,))
        user_result_count = cursor.fetchone()[0]
        remaining_slots = 3 - user_result_count

        cursor.close()
        conn.close()

        return {
            "success": True,
            "message": "记录删除成功",
            "data": {
                "deleted_record_id": benchmark_id,
                "user_result_count": user_result_count,
                "remaining_slots": remaining_slots
            }
        }

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"删除记录失败: {str(e)}"
        )
